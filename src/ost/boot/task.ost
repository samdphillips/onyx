
Object subclass: Task [
    | deadChannel |

    Task class [
        on: aBlock [
            self new
                resume: [
                    aBlock ensure: [ Task current terminate ]
                ];
                yourself
        ]

        new [
            self _taskNew
        ]

        current [
            self _taskCurrent
        ]

        atomicBegin [
            self _taskAtomicBegin
        ]

        atomicEnd [
            self _taskAtomicEnd
        ]
    ]

    resume: aValue [
        self _taskResume: aValue
    ]

    join [
        self isTerminated ifTrue: [ ^ self ].
        deadChannel ifNil:
            [ deadChannel := Channel new ].
        deadChannel next
    ]

    state [
        self _taskState
    ]

    suspend [
        self _taskSuspend
    ]

    isTerminated [
        self state = #terminated
    ]

    terminate [
        deadChannel ifNotNil:
            [ deadChannel nextPut: self ].
        self _taskTerminate
    ]
]

Object subclass: Channel [
    | readers writers |

    Channel class [
        new [
            super new initialize; yourself
        ]
    ]

    initialize [
        readers := OrderedCollection new.
        writers := OrderedCollection new.
    ]

    immediateRead [
        | writer |
        writer := writers removeFirst.
        writer key resume: nil.
        writer value
    ]

    immediateWrite: aValue [
        | reader |
        reader := readers removeFirst.
        reader resume: aValue
    ]

    do: aBlock [
        [ aBlock value: self next ] repeat
    ]

    next [
        [| task |
          writers size > 0
            ifTrue: [ ^ self immediateRead ].
          task := Task current.
          readers add: task.
          task suspend
        ] valueAtomically
    ]

    nextPut: aValue [
        [| task |
          readers size > 0
            ifTrue: [ ^ self immediateWrite: aValue ].
          task := Task current.
          writers add: task -> aValue.
          task suspend
        ] valueAtomically
    ]
]
