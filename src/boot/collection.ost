
Object subclass: Association [
    | key value |

    Association class [
        key: key value: value [
            self new
                initializeKey: key value: value;
                yourself
        ]
    ]

    initializeKey: aKey value: aValue [
        key := aKey.
        value := aValue
    ]

    key   [ key ]

    value [ value ]

    value: anObject [
        value := anObject
    ]
]

Object subclass: Collection [
    asArray [
        Array withAll: self
    ]

    isEmpty [
        self size = 0
    ]

    notEmpty [
        self isEmpty not
    ]

    allSatisfy: aBlock [
        self do: [:e |
            (aBlock value: e)
                ifFalse: [ ^ false ]
        ].
        true
    ]

    anySatisfy: aBlock [
        self do: [:e |
            (aBlock value: e)
                ifTrue: [ ^ true ]
        ].
        false
    ]

    includes: anObject [
        self anySatisfy: [:e | e = anObject ]
    ]

    inject: acc into: aBlock [
        | a |
        a := acc.
        self do: [:e |
            a := aBlock value: a value: e
        ].
        a
    ]

    detect: aBlock ifNone: excBlock [
        self do: [:e |
            (aBlock value: e) ifTrue: [ ^ e ]
        ].
        excBlock value
    ]

    detect: aBlock [
        self detect: aBlock ifNone: [ nil ]
    ]

    species [
        self class
    ]

    select: aBlock [
        | tempColl |
        tempColl := OrderedCollection new: self size.
        self do: [:e|
            (aBlock value: e)
                ifTrue: [ tempColl addLast: e ]
        ].
        self species withAll: tempColl
    ]

    immutableError [
        ImmutableCollectionError signal
    ]

    asTrait [
        self inject: Trait new
             into: [:a :b | a + b ]
    ]
]


Trait named: TExtensibleCollection [
    "
    Implementations required:
    add:
    remove:
    "

    addAll: aCollection [
        aCollection do: [:e | self add: e ]
    ]

    remove: anElement ifAbsent: exceptionBlock [
        (self includes: anElement)
            ifTrue:  [ self remove: anElement ]
            ifFalse: [ exceptionBlock value ]
    ]

    removeAll: aCollection [
        aCollection do: [:e | self remove: e ]
    ]
]


Trait named: TSeqReadableCollection [
    "
    ,
    =
    after:
    at:
    at:ifAbsent:
    before:
    copyFrom:to:
    copyReplaceAll:with:
    copyReplaceFrom:to:with:
    copyReplaceFrom:to:withObject:
    copyReplacing:withObject:
    copyWith:
    copyWithout:
    do:
    findLast:
    indexOf:ifAbsent:
    indexOfSubCollection:startingAt:
    indexOfSubCollection:startingAt:ifAbsent:
    reverse
    reverseDo:
    with:do:
    "

    findFirst: aBlock [
        self keysAndValuesDo: [:i :v |
            (aBlock value: v)
                ifTrue: [ ^i ]
        ].
        nil
    ]

    first [
        self at: 0
    ]

    last [
        self at: self size - 1
    ]

    from: start to: end do: aBlock [
        start to: end do: [:i |
            aBlock value: (self at: i)
        ]
    ]

    from: start to: end keysAndValuesDo: aBlock [
        start to: end do: [:i |
            aBlock value: i value: (self at: i)
        ]
    ]

    indexOf: anElement [
        self findFirst: [:e | e = anElement ]
    ]

    keysAndValuesDo: aBlock [
        self from: 0
             to: self size - 1
             keysAndValuesDo: aBlock
    ]
]


"XXX: move to trait"
Collection subclass: SequencedCollection [
    checkBounds: i [
        (i between: 0 and: self size - 1)
            ifFalse: [ self error: 'out of bounds' ]
    ]

    do: aBlock [
        | i size |
        i    := 0.
        size := self size.

        [ i < size ] whileTrue: [
            aBlock value: (self at: i).
            i := i + 1
        ]
    ]

    at: i put: anObject [
        self checkBounds: i.
        self basicAt: i put: anObject.
        anObject
    ]

    at: i [
        self checkBounds: i.
        self basicAt: i
    ]

    copyFrom: start to: end [
        | size newColl |
        size := end - start + 1.
        newColl := self species new: size.
        0 to: size - 1 do: [:i |
            newColl at: i put: (self at: i + start)
        ].
        newColl
    ]

    replaceFrom: start to: end with: replace startingAt: replaceStart [
        0 to: end - start do: [:i |
            self at: start + i
                 put: (replace at: replaceStart + i)
        ]
    ]
]


SequencedCollection subclass: Array [
    Array class [
        new: size [
            self _arrayNew: size
        ]

        new [
            self new: 0
        ]

        with: anObject [
            (self new: 1)
                at: 0 put: anObject;
                yourself
        ]

        withAll: aCollection [
            | arr i |
            arr := self new: aCollection size.
            i   := 0.

            aCollection do: [:e |
                arr at: i put: e.
                i := i + 1
            ].
            arr
        ]
    ]

    isArray [ true ]

    size [
        self _arraySize
    ]

    basicAt: i put: anObject [
        self _arrayAt: i put: anObject
    ]

    basicAt: i [
        self _arrayAt: i
    ]

    asArray [ self ]

    , aCollection [
        self _arrayAppend: aCollection asArray
    ]
]

SequencedCollection subclass: Interval [
    | start stop step |

    Interval class [
        from: start to: stop [
            self from: start to: stop by: (stop - start) sign
        ]

        from: start to: stop by: step [
            self new
                initializeFrom: start to: stop by: step;
                yourself
        ]
    ]

    initializeFrom: startval to: stopval by: stepval [
        start := startval.
        stop  := stopval.
        step  := stepval.
    ]

    start [ start ]
    stop  [ stop  ]
    step  [ step  ]

    printString [
        start asString, ' to: ', stop asString, ' step: ', step asString
    ]

    size [
        stop - start // step + 1
    ]

    at: i [
        self checkBounds: i.
        (step * i) + start
    ]

    species [
        Array
    ]
]

SequencedCollection subclass: OrderedCollection [
    | elements firstIndex lastIndex |

    OrderedCollection uses:
        { TExtensibleCollection.
          TSeqReadableCollection }.

    OrderedCollection class [
        new [
            self new: self defaultSize
        ]

        new: size [
            super new initialize: size * 2; yourself
        ]

        defaultSize [ 8 ]

        withAll: aCollection [
            | coll |
            coll := self new: aCollection size.
            aCollection do: [:e | coll addLast: e ].
            coll
        ]
    ]

    initialize: size [
        elements := Array new: size.
        firstIndex := lastIndex := size // 2
    ]

    size [ lastIndex - firstIndex ]

    checkGrow: index [
        (index between: 0 and: elements size - 1)
            ifFalse: [ self growForIndex: index ]
    ]

    growForIndex: index [
        | grow |
        grow := self size // 2.

        index < 0
            ifTrue:  [ self growStart: grow ]
            ifFalse: [ self growEnd:   grow ]
    ]

    growStart: grow [
        elements   := (Array new: grow), elements.
        firstIndex := firstIndex + grow.
        lastIndex  := lastIndex  + grow.
    ]

    growEnd: grow [
        elements := elements, (Array new: grow)
    ]

    remove: anElement [
        | index |
        index := self indexOf: anElement.
        index ifNotNil: [
            index = (self size - 1) ifTrue: [
                lastIndex := lastIndex - 1.
                ^anElement
            ].

            index isZero ifTrue: [
                firstIndex := firstIndex + 1.
                ^anElement
            ].

            index := firstIndex + index.
            elements
                replaceFrom: index
                to: (lastIndex - 1)
                with: elements
                startingAt: index + 1.
            ^anElement
        ].
        nil
    ]

    add: anObject [
        self addLast: anObject
    ]

    addLast: anObject [
        self checkGrow: lastIndex + 1.
        elements at: lastIndex put: anObject.
        lastIndex := lastIndex + 1
    ]

    addFirst: anObject [
        self checkGrow: firstIndex - 1.
        elements at: firstIndex - 1 put: anObject.
        firstIndex := firstIndex - 1
    ]

    at: i [
        self checkBounds: i.
        elements at: firstIndex + i
    ]

]
